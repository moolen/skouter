package bpf

import (
	"context"
	"os"
	"testing"

	"github.com/cilium/ebpf"
	"github.com/containerd/cgroups/v2/cgroup2"
	"github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
)

func TestProg(t *testing.T) {
	err := os.MkdirAll("/sys/fs/cgroup/skouter.slice", os.ModePerm)
	assert.NoError(t, err)
	res := cgroup2.Resources{}
	// dummy PID of -1 is used for creating a "general slice" to be used as a parent cgroup.
	_, err = cgroup2.NewSystemd("/", "skouter.slice", -1, &res)
	assert.NoError(t, err)

	log := logrus.New()
	updateChan := make(chan struct{})
	c, err := New(context.Background(), nil, "/sys/fs/cgroup/skouter.slice", "/sys/fs/bpf", "127.0.0.1", false, log, updateChan)
	assert.NoError(t, err)
	assert.NotNil(t, c)
	assert.NotNil(t, c.ingressProg)
	defer c.Close()

	// DNS response
	// example.com: type A, class IN, addr 93.184.216.34
	// 0000   00 00 00 01 00 06 50 e6 36 d4 ab f3 00 00 08 00   ......P.6.......
	// 0010   45 00 00 70 8e 11 00 00 40 11 07 01 c0 a8 b2 01   E..p....@.......
	// 0020   c0 a8 b2 18 00 35 d4 8b 00 5c f9 35 3d 82 81 a0   .....5...\.5=...
	// 0030   00 01 00 01 00 00 00 01 07 65 78 61 6d 70 6c 65   .........example
	// 0040   03 63 6f 6d 00 00 01 00 01 c0 0c 00 01 00 01 00   .com............
	// 0050   00 26 cc 00 04 5d b8 d8 22 00 00 29 04 d0 00 00   .&...].."..)....
	// 0060   00 00 00 1c 00 0a 00 18 0e 3d 25 bb 81 cc c1 69   .........=%....i
	// 0070   01 00 00 00 63 b3 ec 64 f5 2c f8 dd f2 2b 56 70   ....c..d.,...+Vp
	payload := []byte{
		// without ethernet header
		//0x00, 0x00, 0x00, 0x01, 0x00, 0x06, 0x50, 0xe6, 0x36, 0xd4, 0xab, 0xf3, 0x00, 0x00, 0x08, 0x00,

		// padding for testing
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		// padd

		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff,
		0x45, 0x00, 0x00, 0x70, 0x8e, 0x11, 0x00, 0x00, 0x40, 0x11, 0x07, 0x01, 0xc0, 0xa8, 0xb2, 0x01,
		0xc0, 0xa8, 0xb2, 0x18, 0x00, 0x35, 0xd4, 0x8b, 0x00, 0x5c, 0xf9, 0x35, 0x3d, 0x82, 0x81, 0xa0,
		0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
		0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x26, 0xcc, 0x00, 0x04, 0x5d, 0xb8, 0xd8, 0x22, 0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x1c, 0x00, 0x0a, 0x00, 0x18, 0x0e, 0x3d, 0x25, 0xbb, 0x81, 0xcc, 0xc1, 0x69,
		0x01, 0x00, 0x00, 0x00, 0x63, 0xb3, 0xec, 0x64, 0xf5, 0x2c, 0xf8, 0xdd, 0xf2, 0x2b, 0x56, 0x70,

		// padding for testing
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	}

	var out []byte
	if len(payload) > 0 {
		out = make([]byte, len(payload)) // output pad
	}
	result, err := c.ingressProg.Run(&ebpf.RunOptions{
		Data:    payload,
		DataOut: out,
		Repeat:  1,
	})
	assert.NoError(t, err)
	assert.Equal(t, uint32(1), result)
}
